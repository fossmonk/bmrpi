# This script converts a TrueType font (TTF) file into a C header file
# containing a glyph array suitable for use in embedded graphics applications.

# IMPORTANT: This script requires the Pillow and fontTools libraries.
# You can install them with pip:
# pip install Pillow fontTools

from PIL import Image, ImageDraw, ImageFont
import os
import sys

def generate_font_array(ttf_path, output_header_path, font_size, char_set):
    """
    Generates a C header file with a glyph array from a TTF file.

    Args:
        ttf_path (str): Path to the TrueType font file (.ttf).
        output_header_path (str): Path for the output C header file (.h).
        font_size (int): The font size in pixels for rendering.
        char_set (str): A string containing all the characters to be rendered.
    """
    if not os.path.exists(ttf_path):
        print(f"Error: TTF file not found at '{ttf_path}'", file=sys.stderr)
        return

    try:
        # Load the font using Pillow
        font = ImageFont.truetype(ttf_path, font_size)
    except IOError as e:
        print(f"Error: Could not load font '{ttf_path}' - {e}", file=sys.stderr)
        return

    # Determine the maximum width and height of the characters
    max_width = 0
    max_height = 0
    for char in char_set:
        bbox = font.getbbox(char)
        char_width = bbox[2] - bbox[0]
        char_height = bbox[3] - bbox[1]
        max_width = max(max_width, char_width)
        max_height = max(max_height, char_height)

    # Pad the width and height to a multiple of 8, which can be useful for some graphics systems
    # For simplicity, we'll just use the max dimensions.
    # We add a small padding to account for characters that might render slightly outside the bbox.
    glyph_width = max_width + 2
    glyph_height = max_height + 2

    print(f"Rasterizing characters to {glyph_width}x{glyph_height} bitmaps...")

    # Open the output header file in write mode
    with open(output_header_path, 'w') as f:
        # Write file header and necessary defines
        f.write("/*\n")
        f.write(f" * Font data generated from '{os.path.basename(ttf_path)}'\n")
        f.write(" * Generated by ttf_to_c_array.py\n")
        f.write(" * DO NOT EDIT\n")
        f.write(" */\n\n")

        f.write(f"#ifndef GENERATED_FONT_DATA_H\n")
        f.write(f"#define GENERATED_FONT_DATA_H\n\n")

        f.write(f"#include <stdint.h>\n\n")

        f.write(f"#define FONT_GLYPH_WIDTH  {glyph_width}\n")
        f.write(f"#define FONT_GLYPH_HEIGHT {glyph_height}\n")
        f.write(f"#define FONT_NUM_GLYPHS   {len(char_set)}\n\n")

        # Start the array definition
        f.write(f"// Glyphs stored as RGBA (32-bit) pixel data\n")
        f.write(f"const uint32_t font_glyphs[{len(char_set)}][FONT_GLYPH_WIDTH * FONT_GLYPH_HEIGHT] = {{\n")

        # Loop through each character to rasterize and convert to C array format
        for i, char in enumerate(char_set):
            # Create a new image for the character, with a transparent background
            img = Image.new('RGBA', (glyph_width, glyph_height), (0, 0, 0, 0))
            draw = ImageDraw.Draw(img)

            # Draw the character in white
            draw.text((0, 0), char, font=font, fill=(255, 255, 255, 255))

            # Extract the raw pixel data
            pixel_data = list(img.getdata())

            # Start the array for the current glyph
            f.write(f"    // Glyph for character '{char}' (ASCII 0x{ord(char):02x})\n")
            f.write("    {")

            # Format the pixel data as a comma-separated list of hex values
            for j, pixel in enumerate(pixel_data):
                # The pixel data is RGBA. We want to convert it to a single 32-bit integer.
                # The order in the C array will be 0xAARRGGBB.
                r, g, b, a = pixel
                pixel_int = (a << 24) | (r << 16) | (g << 8) | b

                f.write(f"0x{pixel_int:08x}")
                if j < len(pixel_data) - 1:
                    f.write(", ")
                if (j + 1) % 10 == 0:  # Add a line break for readability
                    f.write("\n     ")
            f.write("}")

            if i < len(char_set) - 1:
                f.write(",")
            f.write("\n")

        f.write("};\n\n")

        # Create a helper function to get a pointer to a specific glyph
        f.write("inline const uint32_t* get_font_glyph(char ch) {\n")
        f.write("    // This is a simple linear search. For performance, you may want to use a lookup table.\n")
        f.write("    const char* char_set = \"")
        for char in char_set:
            if char == '"':
                f.write('\\"')
            elif char == '\\':
                f.write('\\\\')
            else:
                f.write(char)
        f.write("\";\n")
        f.write("    for (int i = 0; i < FONT_NUM_GLYPHS; ++i) {\n")
        f.write("        if (char_set[i] == ch) {\n")
        f.write("            return font_glyphs[i];\n")
        f.write("        }\n")
        f.write("    }\n")
        f.write("    // Return a default glyph (e.g., for a non-printable character)\n")
        f.write("    return font_glyphs[0];\n")
        f.write("}\n\n")

        f.write("#endif // GENERATED_FONT_DATA_H\n")

    print(f"Successfully generated C header file at '{output_header_path}'")
    print("----------------------------------------")
    print("How to use the generated header file:")
    print(f"1. Include '{os.path.basename(output_header_path)}' in your C/C++ project.")
    print(f"2. Use the FONT_GLYPH_WIDTH and FONT_GLYPH_HEIGHT defines.")
    print(f"3. Use get_font_glyph(ch) to get the pixel data for a character.")
    print("4. The pixel data is an array of 32-bit integers, representing RGBA pixels.")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python ttf_to_c_array.py <path_to_font.ttf> [optional_output.h]", file=sys.stderr)
        sys.exit(1)

    ttf_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 else "font_data.h"

    # Define the character set to be included in the font array
    # This example uses a common ASCII character set.
    # You can customize this to include any characters you need.
    ascii_charset = "".join(chr(i) for i in range(32, 127))

    generate_font_array(ttf_file, output_file, font_size=16, char_set=ascii_charset)
